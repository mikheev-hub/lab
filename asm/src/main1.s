    PRESERVE8							; 8-битное выравнивание стека
	THUMB								; Режим Thumb (AUL) инструкций

	GET	config.s						; include-файлы
	GET	stm32f10x.s	

	AREA RESET, CODE, READONLY

	; Таблица векторов прерываний
	DCD STACK_TOP						; Указатель на вершину стека
	DCD Reset_Handler					; Вектор сброса

	ENTRY								; Точка входа в программу

Reset_Handler	PROC					; Вектор сброса
	EXPORT  Reset_Handler				; Делаем Reset_Handler видимым вне этого файла

main									; Основная подпрограмма

	MOV32	R0, PERIPH_BB_BASE + \
			RCC_APB2ENR * 32 + \
			4 * 4						; вычисляем адрес для BitBanding 4-го бита регистра RCC_APB2ENR
										; BitAddress = BitBandBase + (RegAddr * 32) + BitNumber * 4
	MOV		R1, #1						; включаем тактирование порта C (в 4-й бит RCC_APB2ENR пишем '1`)
	STR 	R1, [R0]					; загружаем это значение
	
	MOV32	R0, GPIOC_CRH				; адрес порта
	MOV		R1, #0x22					; 12-битная маска настроек для Input, pull-up / pull-down ("100010001000")
	LDR		R2, [R0]					; считать порт
    BFI		R2, R1, #0, #8    			; скопировать биты маски в позицию PIN0, PIN1, PIN2
    STR		R2, [R0]		


	MOV32	R0, PERIPH_BB_BASE + \
			RCC_APB2ENR * 32 + \
		    3 * 4 						; вычисляем адрес для тактирования порта B
	MOV32	R1, #1 						; загружаем это значение
	STR 	R1, [R0] 

	MOV32 	R0, GPIOB_CRL 				; конфигурируем порт B настраиваем его на вход 
	MOV32	R1, #0x88 
	LDR 	R2, [R0] 
	BFI 	R2, R1, #0 ,#8 
	STR 	R2, [R0] 

	MOV32 	R0, GPIOB_BSRR 				; адрес регистра портов BSRR
	MOV 	R1, #(PIN0 << 16) 			; выставляем на ножке B0 логический 0 можно не делать, но обычно делают
	MOV 	R2, #(PIN1 << 16)			; выставляем на ножке B1 логический 0 можно не делать 
	ORR 	R1, R2 						; логическое или
	STR 	R1, [R0] 					; загружаем результат 
	
	MOV R2,#0							; изначальное значение времени положительные полупериод равен 0 
	;------------------
	; Бесконечный цикл
	;------------------		
loop
	;--------------------------------
	; Включение светодидов 
	;--------------------------------		

	MOV32 	R0, GPIOC_BSRR 				
	MOV 	R1, #PIN8 					; влючаем светодиод PB8
	STR 	R1, [R0] 
	MOV		r3,#1						; эти данные переносятся в задержку, сделано так чтобы не делать две разные задержки
	MOV		r4,#0						; значение r4 = 0 строка 117 MUL  r5,r4 MUL - умножение при умножении изачально r5 = длительности периодна на 0 r5 = 0 но при этом MUL	r6,r3 так-как r3 = 1 то r6 будет равен тому же числу при умножении на 1
	BL		DELAY						
	
	MOV32 	R0, GPIOC_BSRR 
	MOV 	R1, #(PIN8 << 16)			; выключаем светодиод PB8
	STR 	R1, [R0] 
	MOV		r3,#0						; все наоборот строчка 65
	MOV		r4,#1
	BL		DELAY
	
	;--------------------------------
	; Подпрограмма обработки кнопок
	;--------------------------------		
	;**Кнопка В0**	
	MOV32	R0, GPIOB_IDR				; адрес входного регистра данных для чтения физического состояния выводов
	LDR		R1, [R0]					; считываем и записываем в регистр R0 значение которое лежит в по адресу GPIOB_IDR
	TST		R1, #0x1					; накладываем маску 0001 делаем логичкское И без сохранения результата 
	BLNE    BUTTON1						; если результат логического И не равен нулю то переходим в процедуру BUTTON1. У нас подтяжка через резистор к земле. Если делать подтяжку к питанию то вместо BLNE нужно записать BLEQ и все будет работать BLEQ - переход в функцию если резульит логического И равен 0
	
	;**Кнопка  B1**		
	MOV32	R0, GPIOB_IDR				; аналогично как с первой кнопкой 
	LDR		R1, [R0]
	TST		R1, #0x2					; маска 0х2 -> 0010 
	BLNE    BUTTON2
	
	
	
	B 		loop	
	ENDP
		
	;--------------------------------
	; Подпрограмма ШИМ 
	;--------------------------------

;**Первая кнопка B0**	
BUTTON1 	PROC    
	ADD		R2, #1						; увеличиваем R2 на единицу при каждом заходе в процедуру инкремент то есть R2 = R2 + 1
	BX		LR							; возвращаемся туда откуда пришли в loop
	ENDP
		
;**Вторая кнопка B1**	
BUTTON2 	PROC  
	CBZ 	R2, BUTTON2_EXIT			; проверяем если R2 = 0 то ничего не делаем и выходим из функции. Так-как R2 - это значчение половижельного фронта он не может быть отрицательным
	SUB		R2, #1						; уменьшаем R2 на единицу при каждом заходе в процедуру деинкремент то есть R2 = R2 - 1
BUTTON2_EXIT
	BX		LR	
	ENDP	

DELAY	 	PROC
	MOV		r6,r2						; значения из процедуры BUTTON1 and BUTTON2
	MUL		r6,r3
	MOV 	r5,#3000					; фиксировананное значение периода 
	MUL		r5,r4
	ADD		r5,r6
DELAY_LOOP	
CBZ 	R5, DELAY_EXIT				    ; если R5 = 0 то выходи переходом в функцию DELAY_EXIT написал другую задержку тебе чтобы было ни как у всех
	SUB		R5,#1						; уменьшаем R5 на единицу 
	B		DELAY_LOOP
	ENDP		
DELAY_EXIT			
	BX		LR
	
	END